diff --git a/math/fxpt_atan2.c b/math/fxpt_atan2.c
index 7d5333d..a84bf53 100644
--- a/math/fxpt_atan2.c
+++ b/math/fxpt_atan2.c
@@ -26,6 +26,12 @@
 #ifdef _MSC_VER
 #define inline __inline
 #define _USE_MATH_DEFINES
+    #if (_MSC_VER < 1800)
+    static __inline long int lrint(double x)
+    {
+        return (long int)((x < (0.0)) ? (x - (0.5)) : (x + (0.5)));
+    }
+    #endif
 #endif
 
 #include <math.h>
@@ -110,6 +116,12 @@ static inline int16_t q15_div(const int16_t numer, const int16_t denom) {
  * @return angle in (val / 32768) * pi radian increments from 0x0000 to 0xFFFF
  */
 uint16_t fxpt_atan2(const int16_t y, const int16_t x) {
+    int16_t nabs_y;
+    int16_t nabs_x;
+    int16_t y_over_x;
+    int16_t x_over_y;
+    int16_t correction;
+    int16_t unrotated;
     if (x == y) { // x/y or y/x would return -1 since 1 isn't representable
         if (y > 0) { // 1/8
             return 8192;
@@ -119,20 +131,20 @@ uint16_t fxpt_atan2(const int16_t y, const int16_t x) {
             return 0;
         }
     }
-    const int16_t nabs_y = s16_nabs(y), nabs_x = s16_nabs(x);
+    nabs_y = s16_nabs(y), nabs_x = s16_nabs(x);
     if (nabs_x < nabs_y) { // octants 1, 4, 5, 8
-        const int16_t y_over_x = q15_div(y, x);
-        const int16_t correction = q15_mul(q15_from_double(0.273 * M_1_PI), s16_nabs(y_over_x));
-        const int16_t unrotated = q15_mul(q15_from_double(0.25 + 0.273 * M_1_PI) + correction, y_over_x);
+        y_over_x = q15_div(y, x);
+        correction = q15_mul(q15_from_double(0.273 * M_1_PI), s16_nabs(y_over_x));
+        unrotated = q15_mul(q15_from_double(0.25 + 0.273 * M_1_PI) + correction, y_over_x);
         if (x > 0) { // octants 1, 8
             return unrotated;
         } else { // octants 4, 5
             return 32768 + unrotated;
         }
     } else { // octants 2, 3, 6, 7
-        const int16_t x_over_y = q15_div(x, y);
-        const int16_t correction = q15_mul(q15_from_double(0.273 * M_1_PI), s16_nabs(x_over_y));
-        const int16_t unrotated = q15_mul(q15_from_double(0.25 + 0.273 * M_1_PI) + correction, x_over_y);
+        x_over_y = q15_div(x, y);
+        correction = q15_mul(q15_from_double(0.273 * M_1_PI), s16_nabs(x_over_y));
+        unrotated = q15_mul(q15_from_double(0.25 + 0.273 * M_1_PI) + correction, x_over_y);
         if (y > 0) { // octants 2, 3
             return 16384 - unrotated;
         } else { // octants 6, 7
