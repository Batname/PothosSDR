diff --git a/lib/add_tailbits_bb_impl.cc b/lib/add_tailbits_bb_impl.cc
index 12304a3..38deba3 100644
--- a/lib/add_tailbits_bb_impl.cc
+++ b/lib/add_tailbits_bb_impl.cc
@@ -66,7 +66,7 @@ namespace gr {
 		unsigned char *out = (unsigned char *) output_items[0];
         const int n_vectors = noutput_items/(d_vlen+d_n_tail);
         // set tailbits to zero TODO: make tailbits configurable
-		unsigned char tailbits[(const int) d_n_tail];
+		__GR_VLA(unsigned char, tailbits, (const int) d_n_tail);
 		memset(tailbits, 0, d_n_tail);
 
 		for( int i = 0; i < n_vectors; i++)
diff --git a/lib/audio_encoder_sb_impl.cc b/lib/audio_encoder_sb_impl.cc
index 179e396..1f6cabf 100644
--- a/lib/audio_encoder_sb_impl.cc
+++ b/lib/audio_encoder_sb_impl.cc
@@ -167,7 +167,7 @@ namespace gr {
 		/* encode PCM stream and make it DRM compliant. write to output buffer (in make_drm_compliant()) */
 		// init AAC buffer
 		//std::cout << "aac_encode()" << std::endl;
-		unsigned char aac_buffer[(const unsigned long) d_n_max_bytes_out * (const unsigned long) d_n_aac_frames];
+		__GR_VLA(unsigned char, aac_buffer, (const unsigned long) d_n_max_bytes_out * (const unsigned long) d_n_aac_frames);
 		aac_encode(aac_buffer); // encodes pcm data for 1 super transmission frame
 		//std::cout << "d_out: " << (long) d_out << ", bits written: " << d_out - d_out_prev << std::endl;
 		d_out_prev = d_out;
@@ -197,8 +197,8 @@ namespace gr {
 		d_n_bytes_encoded.clear();
 
 		// allocate tmp input buffers for PCM and AAC samples
-		float tmp_pcm_buffer[(const unsigned long) d_transform_length]; // if multiple super audio frames are processed, move this outside this function to avoid multiple allocation
-		unsigned char tmp_aac_buffer[(const unsigned long) d_n_max_bytes_out];
+		__GR_VLA(float, tmp_pcm_buffer, (const unsigned long) d_transform_length); // if multiple super audio frames are processed, move this outside this function to avoid multiple allocation
+		__GR_VLA(unsigned char, tmp_aac_buffer, (const unsigned long) d_n_max_bytes_out);
 
 		for (int j = 0; j < d_n_aac_frames; j++)
 		{
@@ -218,9 +218,9 @@ namespace gr {
 	audio_encoder_sb_impl::make_drm_compliant(unsigned char* aac_buffer)
 	{
 		/* init buffers for CRC, payload and frame lengths */
-		unsigned char crc_bits[(const int) d_n_aac_frames];
-		int frame_length[(const int) d_n_aac_frames];
-		unsigned char* frame_pos[(const int) d_n_aac_frames];
+		__GR_VLA(unsigned char, crc_bits, (const int) d_n_aac_frames);
+		__GR_VLA(int, frame_length, (const int) d_n_aac_frames);
+		__GR_VLA(unsigned char*, frame_pos, (const int) d_n_aac_frames);
 		frame_pos[0] = aac_buffer;
 
 		/* create header ( accumulated frame lengths | padding | CRC | audio ) */
@@ -322,7 +322,7 @@ namespace gr {
 		//std::cout << "len_msg_bit: " << len_msg_bit << std::endl;
 		d_n_text_frames = len_msg_bit/(4*8);
 		//std::cout << "d_n_text_frames: " << d_n_text_frames << ", n_segments: " << n_segments << std::endl;
-		unsigned char msg[len_msg_bit];
+		__GR_VLA(unsigned char, msg, len_msg_bit);
 		memset(msg, 9, len_msg_bit); // set to 9 for debugging purposes
 
 		//std::cout << "msg address: " << (long) &msg[0] << std::endl;
diff --git a/lib/cell_mapping_cc_impl.cc b/lib/cell_mapping_cc_impl.cc
index 0041eb5..52cba78 100644
--- a/lib/cell_mapping_cc_impl.cc
+++ b/lib/cell_mapping_cc_impl.cc
@@ -18,6 +18,7 @@
  * Boston, MA 02110-1301, USA.
  */
 
+#define _USE_MATH_DEFINES //define before including math header
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -163,9 +164,9 @@ namespace gr {
 		int freq_pil[3][2];
 		const int time_rows = d_time_rows; // this way we can instance an array with this variable
 		int afs_pil[NUM_AFS_PILOTS][3]; // only used for RM E
-		int time_pil[time_rows][2];
+		int time_pil[RMA_NUM_TIME_PIL][2];
 		const int fac_rows = d_fac_rows;
-		int fac_pos[fac_rows][2];
+		int fac_pos[N_FAC_DRM][2];
 		int unused_carriers_A[3] = {-1, 0, 1};
 
 		switch(d_RM)
diff --git a/lib/drm_config.h b/lib/drm_config.h
index 1758e9f..572648f 100644
--- a/lib/drm_config.h
+++ b/lib/drm_config.h
@@ -22,12 +22,13 @@
 #ifndef DRM_CONFIG_H_
 #define DRM_CONFIG_H_
 
+#include <drm/api.h>
 #include "drm_tables.h"
 #include "drm_global_constants.h"
 #include <iostream>
 
 /* class holding the initial (user defined) parameters from which the others are derived */
-class config
+class DRM_API config
 {
 	unsigned short d_RM; // robustness mode (0-4 correspond to A-E)
 	unsigned short d_SO; // spectrum occupancy (0-5)
diff --git a/lib/drm_params.h b/lib/drm_params.h
index 13a0e05..afdd419 100644
--- a/lib/drm_params.h
+++ b/lib/drm_params.h
@@ -22,6 +22,7 @@
 #ifndef _DRM_PARAMS_H_
 #define _DRM_PARAMS_H_
 
+#include <drm/api.h>
 #include "drm_global_constants.h"
 #include "drm_tables.h"
 #include "drm_config.h"
@@ -30,7 +31,7 @@
 #include <cmath>
 
 /* classes holding the derived parameters and init routines (where parameters are calculated)*/
-class global_params
+class DRM_API global_params
 {
 public:
 	virtual void init(config* cfg) = 0;
@@ -39,7 +40,7 @@ public:
 	virtual ~global_params(){};
 };
 
-class ofdm_params : public global_params
+class DRM_API ofdm_params : public global_params
 {
 	unsigned int d_nfft; // FFT length
 	unsigned int d_n_cp; // length of guard interval (samples)
@@ -71,7 +72,7 @@ public:
 	void init(config* cfg);
 };
 
-class channel_params : public global_params
+class DRM_API channel_params : public global_params
 {
 protected:
 	std::vector< int > d_r_p; // index for tailbit puncturing pattern
@@ -94,7 +95,7 @@ public:
 	virtual ~channel_params(){};
 };
 
-class control_chan_params : public channel_params
+class DRM_API control_chan_params : public channel_params
 {
 protected:
 	unsigned int d_L; // length in bits
@@ -123,7 +124,7 @@ public:
 	virtual ~control_chan_params(){};
 };
 
-class sdc_params : public control_chan_params
+class DRM_API sdc_params : public control_chan_params
 {
 	float d_R_1; // coderate R_1
 	unsigned short d_R_1_enum; // enumerator of R_1
@@ -158,7 +159,7 @@ public:
 	void init(config* cfg);
 };
 
-class fac_params : public control_chan_params
+class DRM_API fac_params : public control_chan_params
 {
 public:
 	fac_params(){};
@@ -167,7 +168,7 @@ public:
 	void init(config* cfg);
 };
 
-class msc_params : public channel_params
+class DRM_API msc_params : public channel_params
 {
 	/* NOTE: so far, only SM is implemented! TODO: implement hierarchical mapping */
 	unsigned int d_L_MUX; // number of bits per multiplex frame
diff --git a/lib/drm_tables.h b/lib/drm_tables.h
index 807ee03..2be85d8 100644
--- a/lib/drm_tables.h
+++ b/lib/drm_tables.h
@@ -22,12 +22,13 @@
 #ifndef DRM_TABLES_H_
 #define DRM_TABLES_H_
 
+#include <drm/api.h>
 #include "drm_global_constants.h"
 #include <vector>
 #include <cmath>
 #include <complex>
 
-class tables
+class DRM_API tables
 {
 	public:
 
diff --git a/lib/drm_tables_mapping.cc b/lib/drm_tables_mapping.cc
index 2ddbc79..4a1d704 100644
--- a/lib/drm_tables_mapping.cc
+++ b/lib/drm_tables_mapping.cc
@@ -21,8 +21,8 @@
  * Boston, MA 02110-1301, USA.
  */
 
+#define _USE_MATH_DEFINES //define before including math header
 #include "drm_tables.h"
-#define _USE_MATH_DEFINES
 
 /* frequency reference cells [carrier index][phase_index(0,k)]
  * corresponds to 750 Hz, 2250 Hz and 3000 Hz */
diff --git a/lib/drm_util.cc b/lib/drm_util.cc
index cccbde7..7a392f6 100644
--- a/lib/drm_util.cc
+++ b/lib/drm_util.cc
@@ -80,10 +80,10 @@ void
 enqueue_crc(unsigned char* ptr, transm_params* tp, int len, const unsigned short ord) //  see DRM standard, annex D
 {
 	unsigned short rob_mode = tp->cfg().RM();
-	unsigned char shift_reg[ord]; // shift register of length ord
-	unsigned char shift_reg_prev[ord]; // state of register before last shift
+	__GR_VLA(unsigned char, shift_reg, ord); // shift register of length ord
+	__GR_VLA(unsigned char, shift_reg_prev, ord); // state of register before last shift
 	unsigned char next_lsb; // the bit that results out of XORing the MSb with the input
-	unsigned char crc_word[ord]; // CRC word
+	__GR_VLA(unsigned char, crc_word, ord); // CRC word
 	memset(shift_reg, 1, ord); // set all stages to one (see DRM standard, annex D)
 	memset(shift_reg_prev, 0, ord); // just for debugging purposes
 	switch(ord)
diff --git a/lib/generate_sdc_b_impl.cc b/lib/generate_sdc_b_impl.cc
index 1d9b7c7..922d0ac 100644
--- a/lib/generate_sdc_b_impl.cc
+++ b/lib/generate_sdc_b_impl.cc
@@ -189,7 +189,7 @@ namespace gr {
 				gr_vector_void_star &output_items)
 	{
 		const unsigned int sdc_length = d_tp->sdc().L();
-		unsigned char data[sdc_length];
+		__GR_VLA(unsigned char, data, sdc_length);
 		unsigned char *out = (unsigned char *) output_items[0];
 		memset(data, 0, sdc_length);
 
diff --git a/lib/m3ufile_source_f_impl.cc b/lib/m3ufile_source_f_impl.cc
index 737b0d3..f306942 100644
--- a/lib/m3ufile_source_f_impl.cc
+++ b/lib/m3ufile_source_f_impl.cc
@@ -118,7 +118,7 @@ namespace gr {
     {
         char ext_header[] = "#EXTM3U";
         const int len_ext_header = strlen(ext_header);
-        char linebuf[len_ext_header];
+        __GR_VLA(char, linebuf, len_ext_header);
         d_m3u_file.getline(linebuf, len_ext_header+1); // +1 to get the newline character
         if(strcmp(linebuf, ext_header) == 0) // return 0 if equal
         {
diff --git a/lib/qam_map_bc_impl.cc b/lib/qam_map_bc_impl.cc
index 50c25f3..24b26f3 100644
--- a/lib/qam_map_bc_impl.cc
+++ b/lib/qam_map_bc_impl.cc
@@ -75,7 +75,7 @@ namespace gr {
 			  gr_vector_const_void_star &input_items,
 			  gr_vector_void_star &output_items)
 	{
-		unsigned char *in[d_n_inputs];
+		__GR_VLA(unsigned char *, in, d_n_inputs);
 		gr_complex *out = (gr_complex *) output_items[0];
 		int n_vectors = noutput_items/d_vlen_out;
 		// define input pointers
diff --git a/lib/scrambler_bb_impl.cc b/lib/scrambler_bb_impl.cc
index 19bef29..ec4bbcb 100644
--- a/lib/scrambler_bb_impl.cc
+++ b/lib/scrambler_bb_impl.cc
@@ -67,7 +67,7 @@ namespace gr {
 				for(int j = 0; j < n_vectors; j++)
 				{
 					// Generate PRBS of length block_len (G(x) = x^9 + x^5 + 1)
-					unsigned char prbs[n_reset]; // Pseudo random bit sequence array
+					__GR_VLA(unsigned char, prbs, n_reset); // Pseudo random bit sequence array
 					unsigned char lfsr[9] = {1, 1, 1, 1, 1, 1, 1, 1, 1}; // inital state: all ones
 					unsigned char lfsr_prev[9]; // holds previous shift register state while shifting
 					unsigned char next_bit;
