diff --git a/gr-drm/CMakeLists.txt b/gr-drm/CMakeLists.txt
index 08c60c8..6239fd0 100644
--- a/gr-drm/CMakeLists.txt
+++ b/gr-drm/CMakeLists.txt
@@ -100,7 +100,7 @@ find_package(CppUnit)
 # components required to the list of GR_REQUIRED_COMPONENTS (in all
 # caps such as FILTER or FFT) and change the version to the minimum
 # API compatible version required.
-set(GR_REQUIRED_COMPONENTS RUNTIME)
+set(GR_REQUIRED_COMPONENTS RUNTIME PMT)
 find_package(Gnuradio "3.7.2" REQUIRED)
 
 if(NOT CPPUNIT_FOUND)
@@ -118,7 +118,7 @@ include_directories(
     ${Boost_INCLUDE_DIRS}
     ${CPPUNIT_INCLUDE_DIRS}
     ${GNURADIO_ALL_INCLUDE_DIRS}
-    ${Faac_INCLUDE_DIRS}
+    ${Faac_INCLUDE_DIR}
 )
 
 link_directories(
diff --git a/gr-drm/lib/add_tailbits_vbvb_impl.cc b/gr-drm/lib/add_tailbits_vbvb_impl.cc
index 04a6340..606ab12 100644
--- a/gr-drm/lib/add_tailbits_vbvb_impl.cc
+++ b/gr-drm/lib/add_tailbits_vbvb_impl.cc
@@ -63,7 +63,11 @@ namespace gr {
 		unsigned char *out = (unsigned char *) output_items[0];
 
 		// set tailbits to zero TODO: make tailbits configurable
+        #ifdef _MSC_VER
+        unsigned char *tailbits = (unsigned char *)alloca((const int) d_n_tail);
+        #else
 		unsigned char tailbits[(const int) d_n_tail];
+        #endif
 		memset(tailbits, 0, d_n_tail);
 
 		for( int i = 0; i < noutput_items; i++)
diff --git a/gr-drm/lib/audio_encoder_svb_impl.cc b/gr-drm/lib/audio_encoder_svb_impl.cc
index d4dbcf0..70d8292 100644
--- a/gr-drm/lib/audio_encoder_svb_impl.cc
+++ b/gr-drm/lib/audio_encoder_svb_impl.cc
@@ -166,7 +166,11 @@ namespace gr {
 		/* encode PCM stream and make it DRM compliant. write to output buffer (in make_drm_compliant()) */
 		// init AAC buffer
 		//std::cout << "aac_encode()" << std::endl;
+        #ifdef _MSC_VER
+        unsigned char *aac_buffer = (unsigned char *)alloca((const unsigned long) d_n_max_bytes_out * (const unsigned long) d_n_aac_frames);
+        #else
 		unsigned char aac_buffer[(const unsigned long) d_n_max_bytes_out * (const unsigned long) d_n_aac_frames];
+        #endif
 		aac_encode(aac_buffer); // encodes pcm data for 1 super transmission frame
 		//std::cout << "d_out: " << (long) d_out << ", bits written: " << d_out - d_out_prev << std::endl;
 		d_out_prev = d_out;
@@ -196,8 +200,13 @@ namespace gr {
 		d_n_bytes_encoded.clear();
 
 		// allocate tmp input buffers for PCM and AAC samples
+        #ifdef _MSC_VER
+		float *tmp_pcm_buffer = (float *)alloca(sizeof(float)*((const unsigned long) d_transform_length)); // if multiple super audio frames are processed, move this outside this function to avoid multiple allocation
+		unsigned char *tmp_aac_buffer = (unsigned char *)alloca((const unsigned long) d_n_max_bytes_out);
+        #else
 		float tmp_pcm_buffer[(const unsigned long) d_transform_length]; // if multiple super audio frames are processed, move this outside this function to avoid multiple allocation
 		unsigned char tmp_aac_buffer[(const unsigned long) d_n_max_bytes_out];
+        #endif
 
 		for (int j = 0; j < d_n_aac_frames; j++)
 		{
@@ -217,9 +226,15 @@ namespace gr {
 	audio_encoder_svb_impl::make_drm_compliant(unsigned char* aac_buffer)
 	{
 		/* init buffers for CRC, payload and frame lengths */
+        #ifdef _MSC_VER
+		unsigned char *crc_bits = (unsigned char *)alloca((const int) d_n_aac_frames);
+		int *frame_length = (int *)alloca(sizeof(int)*((const int) d_n_aac_frames));
+		unsigned char **frame_pos = (unsigned char **)alloca(sizeof(unsigned char *)*((const int) d_n_aac_frames));
+        #else
 		unsigned char crc_bits[(const int) d_n_aac_frames];
 		int frame_length[(const int) d_n_aac_frames];
 		unsigned char* frame_pos[(const int) d_n_aac_frames];
+        #endif
 		frame_pos[0] = aac_buffer;
 
 		/* create header ( accumulated frame lengths | padding | CRC | audio ) */
@@ -321,7 +336,11 @@ namespace gr {
 		//std::cout << "len_msg_bit: " << len_msg_bit << std::endl;
 		d_n_text_frames = len_msg_bit/(4*8);
 		//std::cout << "d_n_text_frames: " << d_n_text_frames << ", n_segments: " << n_segments << std::endl;
-		unsigned char msg[len_msg_bit];
+		#ifdef _MSC_VER
+        unsigned char *msg = (unsigned char *)alloca(len_msg_bit);
+        #else
+        unsigned char msg[len_msg_bit];
+        #endif
 		memset(msg, 9, len_msg_bit); // set to 9 for debugging purposes
 
 		//std::cout << "msg address: " << (long) &msg[0] << std::endl;
diff --git a/gr-drm/lib/cell_mapping_vcvc_impl.cc b/gr-drm/lib/cell_mapping_vcvc_impl.cc
index 477b819..7bc0f93 100644
--- a/gr-drm/lib/cell_mapping_vcvc_impl.cc
+++ b/gr-drm/lib/cell_mapping_vcvc_impl.cc
@@ -18,6 +18,7 @@
  * Boston, MA 02110-1301, USA.
  */
 
+#define _USE_MATH_DEFINES
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -150,9 +151,17 @@ namespace gr {
 		int freq_pil[3][2];
 		const int time_rows = d_time_rows; // this way we can instance an array with this variable
 		int afs_pil[NUM_AFS_PILOTS][3]; // only used for RM E
+        #ifdef _MSC_VER
+		int **time_pil = (int **)alloca(sizeof(int *)*time_rows);
+        for (size_t i = 0; i < time_rows; i++) time_pil[i] = (int *)alloca(sizeof(int)*2);
+		const int fac_rows = d_fac_rows;
+        int **fac_pos = (int **)alloca(sizeof(int *)*fac_rows);
+        for (size_t i = 0; i < fac_rows; i++) fac_pos[i] = (int *)alloca(sizeof(int)*2);
+        #else
 		int time_pil[time_rows][2];
 		const int fac_rows = d_fac_rows;
 		int fac_pos[fac_rows][2];
+        #endif
 		int unused_carriers_A[3] = {-1, 0, 1};
 
 		switch(d_RM)
diff --git a/gr-drm/lib/drm_config.h b/gr-drm/lib/drm_config.h
index 9f4c046..c97a4bb 100644
--- a/gr-drm/lib/drm_config.h
+++ b/gr-drm/lib/drm_config.h
@@ -22,12 +22,13 @@
 #ifndef DRM_CONFIG_H_
 #define DRM_CONFIG_H_
 
+#include <drm/api.h>
 #include "drm_tables.h"
 #include "drm_global_constants.h"
 #include <iostream>
 
 /* class holding the initial (user defined) parameters from which the others are derived */
-class config
+class DRM_API config
 {
 	unsigned short d_RM; // robustness mode (0-4 correspond to A-E)
 	unsigned short d_SO; // spectrum occupancy (0-5)
diff --git a/gr-drm/lib/drm_params.h b/gr-drm/lib/drm_params.h
index 13a0e05..afdd419 100644
--- a/gr-drm/lib/drm_params.h
+++ b/gr-drm/lib/drm_params.h
@@ -22,6 +22,7 @@
 #ifndef _DRM_PARAMS_H_
 #define _DRM_PARAMS_H_
 
+#include <drm/api.h>
 #include "drm_global_constants.h"
 #include "drm_tables.h"
 #include "drm_config.h"
@@ -30,7 +31,7 @@
 #include <cmath>
 
 /* classes holding the derived parameters and init routines (where parameters are calculated)*/
-class global_params
+class DRM_API global_params
 {
 public:
 	virtual void init(config* cfg) = 0;
@@ -39,7 +40,7 @@ public:
 	virtual ~global_params(){};
 };
 
-class ofdm_params : public global_params
+class DRM_API ofdm_params : public global_params
 {
 	unsigned int d_nfft; // FFT length
 	unsigned int d_n_cp; // length of guard interval (samples)
@@ -71,7 +72,7 @@ public:
 	void init(config* cfg);
 };
 
-class channel_params : public global_params
+class DRM_API channel_params : public global_params
 {
 protected:
 	std::vector< int > d_r_p; // index for tailbit puncturing pattern
@@ -94,7 +95,7 @@ public:
 	virtual ~channel_params(){};
 };
 
-class control_chan_params : public channel_params
+class DRM_API control_chan_params : public channel_params
 {
 protected:
 	unsigned int d_L; // length in bits
@@ -123,7 +124,7 @@ public:
 	virtual ~control_chan_params(){};
 };
 
-class sdc_params : public control_chan_params
+class DRM_API sdc_params : public control_chan_params
 {
 	float d_R_1; // coderate R_1
 	unsigned short d_R_1_enum; // enumerator of R_1
@@ -158,7 +159,7 @@ public:
 	void init(config* cfg);
 };
 
-class fac_params : public control_chan_params
+class DRM_API fac_params : public control_chan_params
 {
 public:
 	fac_params(){};
@@ -167,7 +168,7 @@ public:
 	void init(config* cfg);
 };
 
-class msc_params : public channel_params
+class DRM_API msc_params : public channel_params
 {
 	/* NOTE: so far, only SM is implemented! TODO: implement hierarchical mapping */
 	unsigned int d_L_MUX; // number of bits per multiplex frame
diff --git a/gr-drm/lib/drm_tables.h b/gr-drm/lib/drm_tables.h
index 807ee03..2be85d8 100644
--- a/gr-drm/lib/drm_tables.h
+++ b/gr-drm/lib/drm_tables.h
@@ -22,12 +22,13 @@
 #ifndef DRM_TABLES_H_
 #define DRM_TABLES_H_
 
+#include <drm/api.h>
 #include "drm_global_constants.h"
 #include <vector>
 #include <cmath>
 #include <complex>
 
-class tables
+class DRM_API tables
 {
 	public:
 
diff --git a/gr-drm/lib/drm_tables_mapping.cc b/gr-drm/lib/drm_tables_mapping.cc
index 4960767..dc1788f 100644
--- a/gr-drm/lib/drm_tables_mapping.cc
+++ b/gr-drm/lib/drm_tables_mapping.cc
@@ -21,6 +21,7 @@
  * Boston, MA 02110-1301, USA.
  */
 
+#define _USE_MATH_DEFINES
 #include "drm_tables.h"
 
 /* frequency reference cells [carrier index][phase_index(0,k)]
diff --git a/gr-drm/lib/drm_transm_params.h b/gr-drm/lib/drm_transm_params.h
index c3d9be1..33bfae4 100644
--- a/gr-drm/lib/drm_transm_params.h
+++ b/gr-drm/lib/drm_transm_params.h
@@ -22,10 +22,11 @@
 #ifndef DRM_TRANSM_PARAMS_H_
 #define DRM_TRANSM_PARAMS_H_
 
+#include <drm/api.h>
 #include "drm_config.h"
 #include "drm_params.h"
 
-class transm_params
+class DRM_API transm_params
 {
 	config* d_cfg;
 	ofdm_params* d_ofdm;
diff --git a/gr-drm/lib/drm_util.cc b/gr-drm/lib/drm_util.cc
index cccbde7..d4b2f46 100644
--- a/gr-drm/lib/drm_util.cc
+++ b/gr-drm/lib/drm_util.cc
@@ -80,10 +80,17 @@ void
 enqueue_crc(unsigned char* ptr, transm_params* tp, int len, const unsigned short ord) //  see DRM standard, annex D
 {
 	unsigned short rob_mode = tp->cfg().RM();
+    #ifdef _MSC_VER
+	unsigned char *shift_reg = (unsigned char *)alloca(ord); // shift register of length ord
+	unsigned char *shift_reg_prev = (unsigned char *)alloca(ord); // state of register before last shift
+	unsigned char next_lsb; // the bit that results out of XORing the MSb with the input
+	unsigned char *crc_word = (unsigned char *)alloca(ord); // CRC word
+    #else
 	unsigned char shift_reg[ord]; // shift register of length ord
 	unsigned char shift_reg_prev[ord]; // state of register before last shift
 	unsigned char next_lsb; // the bit that results out of XORing the MSb with the input
 	unsigned char crc_word[ord]; // CRC word
+    #endif
 	memset(shift_reg, 1, ord); // set all stages to one (see DRM standard, annex D)
 	memset(shift_reg_prev, 0, ord); // just for debugging purposes
 	switch(ord)
diff --git a/gr-drm/lib/drm_util.h b/gr-drm/lib/drm_util.h
index c2686c6..ca3d77f 100644
--- a/gr-drm/lib/drm_util.h
+++ b/gr-drm/lib/drm_util.h
@@ -22,6 +22,7 @@
 #ifndef _DRM_UTIL_H
 #define _DRM_UTIL_H
 
+#include <drm/api.h>
 #include <cstring>
 #include <cmath>
 #include <vector>
@@ -29,21 +30,21 @@
 
 
 // enqueue bit array arr of lenght len at address ptr
-void enqueue_bits(unsigned char* &ptr, unsigned int len, unsigned char arr[]);
+DRM_API void enqueue_bits(unsigned char* &ptr, unsigned int len, unsigned char arr[]);
 
 // enqueue bit array of length len with decimal representation val (max->unsigned int) at address ptr
-void enqueue_bits_dec(unsigned char* &ptr, unsigned int len, unsigned int val);
+DRM_API void enqueue_bits_dec(unsigned char* &ptr, unsigned int len, unsigned int val);
 
 // enqueue crc word of order ord after bit sequence of length len at address ptr
-void enqueue_crc(unsigned char* ptr, transm_params* tp, int len, unsigned short ord);
+DRM_API void enqueue_crc(unsigned char* ptr, transm_params* tp, int len, unsigned short ord);
 
 // enqueue array arr of lenght len to vector vec
-void enqueue_array_to_vector(std::vector< unsigned char >* vec, const unsigned char* arr, int len);
+DRM_API void enqueue_array_to_vector(std::vector< unsigned char >* vec, const unsigned char* arr, int len);
 
 // dequeue 8 bits from array ptr and interpret them as unsigned char
-unsigned char dequeue_char(unsigned char* &ptr);
+DRM_API unsigned char dequeue_char(unsigned char* &ptr);
 
 // dequeue array of length len from array ptr (unsigned char) and interpret as unsigned int
-unsigned int dequeue_dec(unsigned char* &ptr, unsigned int len);
+DRM_API unsigned int dequeue_dec(unsigned char* &ptr, unsigned int len);
 
 #endif
diff --git a/gr-drm/lib/generate_sdc_vb_impl.cc b/gr-drm/lib/generate_sdc_vb_impl.cc
index 6076992..068f700 100644
--- a/gr-drm/lib/generate_sdc_vb_impl.cc
+++ b/gr-drm/lib/generate_sdc_vb_impl.cc
@@ -188,7 +188,11 @@ namespace gr {
 				gr_vector_void_star &output_items)
 	{
 		const unsigned int sdc_length = d_tp->sdc().L();
+        #ifdef _MSC_VER
+        unsigned char *data = (unsigned char *)alloca(sdc_length);
+        #else
 		unsigned char data[sdc_length];
+        #endif
 		memset(data, 0, sdc_length);
 
 		init_data(data);
diff --git a/gr-drm/lib/m3ufile_source_f_impl.cc b/gr-drm/lib/m3ufile_source_f_impl.cc
index 737b0d3..4214c88 100644
--- a/gr-drm/lib/m3ufile_source_f_impl.cc
+++ b/gr-drm/lib/m3ufile_source_f_impl.cc
@@ -118,7 +118,11 @@ namespace gr {
     {
         char ext_header[] = "#EXTM3U";
         const int len_ext_header = strlen(ext_header);
+        #ifdef _MSC_VER
+        char *linebuf = (char *)alloca(len_ext_header);
+        #else
         char linebuf[len_ext_header];
+        #endif
         d_m3u_file.getline(linebuf, len_ext_header+1); // +1 to get the newline character
         if(strcmp(linebuf, ext_header) == 0) // return 0 if equal
         {
diff --git a/gr-drm/lib/partitioning_vbvb_impl.cc b/gr-drm/lib/partitioning_vbvb_impl.cc
index b801252..bf0638d 100644
--- a/gr-drm/lib/partitioning_vbvb_impl.cc
+++ b/gr-drm/lib/partitioning_vbvb_impl.cc
@@ -60,7 +60,11 @@ namespace gr {
 			  gr_vector_void_star &output_items)
     {
 		unsigned char *in = (unsigned char *) input_items[0];
+        #ifdef _MSC_VER
+		unsigned char **out = (unsigned char **)alloca(sizeof(unsigned char *)*(d_n_out));
+        #else
 		unsigned char *out[d_n_out];
+        #endif
 		for(int i = 0; i < d_n_out; i++)
 		{
 			out[i] = (unsigned char*) output_items[i];
diff --git a/gr-drm/lib/qam_map_vbvc_impl.cc b/gr-drm/lib/qam_map_vbvc_impl.cc
index 9abc2d1..6f949af 100644
--- a/gr-drm/lib/qam_map_vbvc_impl.cc
+++ b/gr-drm/lib/qam_map_vbvc_impl.cc
@@ -73,7 +73,11 @@ namespace gr {
 			  gr_vector_const_void_star &input_items,
 			  gr_vector_void_star &output_items)
 	{
+        #ifdef _MSC_VER
+		unsigned char **in = (unsigned char **)alloca(sizeof(unsigned char *)*(d_n_inputs));
+        #else
 		unsigned char *in[d_n_inputs];
+        #endif
 		gr_complex *out = (gr_complex *) output_items[0];
 
 		// define input pointers
diff --git a/gr-drm/lib/scrambler_vbvb_impl.cc b/gr-drm/lib/scrambler_vbvb_impl.cc
index 3dc20a3..a3bd41c 100644
--- a/gr-drm/lib/scrambler_vbvb_impl.cc
+++ b/gr-drm/lib/scrambler_vbvb_impl.cc
@@ -66,7 +66,11 @@ namespace gr {
 				for(int j = 0; j < noutput_items; j++)
 				{
 					// Generate PRBS of length block_len (G(x) = x^9 + x^5 + 1)
+                    #ifdef _MSC_VER
+					unsigned char *prbs = (unsigned char *)alloca(n_reset); // Pseudo random bit sequence array
+                    #else
 					unsigned char prbs[n_reset]; // Pseudo random bit sequence array
+                    #endif
 					unsigned char lfsr[9] = {1, 1, 1, 1, 1, 1, 1, 1, 1}; // inital state: all ones
 					unsigned char lfsr_prev[9]; // holds previous shift register state while shifting
 					unsigned char next_bit;
