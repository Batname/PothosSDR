diff --git a/gr-drm/lib/add_tailbits_vbvb_impl.cc b/gr-drm/lib/add_tailbits_vbvb_impl.cc
index 04a6340..606ab12 100644
--- a/gr-drm/lib/add_tailbits_vbvb_impl.cc
+++ b/gr-drm/lib/add_tailbits_vbvb_impl.cc
@@ -63,7 +63,11 @@ namespace gr {
 		unsigned char *out = (unsigned char *) output_items[0];
 
 		// set tailbits to zero TODO: make tailbits configurable
+        #ifdef _MSC_VER
+        unsigned char *tailbits = (unsigned char *)alloca((const int) d_n_tail);
+        #else
 		unsigned char tailbits[(const int) d_n_tail];
+        #endif
 		memset(tailbits, 0, d_n_tail);
 
 		for( int i = 0; i < noutput_items; i++)
diff --git a/gr-drm/lib/audio_encoder_svb_impl.cc b/gr-drm/lib/audio_encoder_svb_impl.cc
index d4dbcf0..70d8292 100644
--- a/gr-drm/lib/audio_encoder_svb_impl.cc
+++ b/gr-drm/lib/audio_encoder_svb_impl.cc
@@ -166,7 +166,11 @@ namespace gr {
 		/* encode PCM stream and make it DRM compliant. write to output buffer (in make_drm_compliant()) */
 		// init AAC buffer
 		//std::cout << "aac_encode()" << std::endl;
+        #ifdef _MSC_VER
+        unsigned char *aac_buffer = (unsigned char *)alloca((const unsigned long) d_n_max_bytes_out * (const unsigned long) d_n_aac_frames);
+        #else
 		unsigned char aac_buffer[(const unsigned long) d_n_max_bytes_out * (const unsigned long) d_n_aac_frames];
+        #endif
 		aac_encode(aac_buffer); // encodes pcm data for 1 super transmission frame
 		//std::cout << "d_out: " << (long) d_out << ", bits written: " << d_out - d_out_prev << std::endl;
 		d_out_prev = d_out;
@@ -196,8 +200,13 @@ namespace gr {
 		d_n_bytes_encoded.clear();
 
 		// allocate tmp input buffers for PCM and AAC samples
+        #ifdef _MSC_VER
+		float *tmp_pcm_buffer = (float *)alloca(sizeof(float)*((const unsigned long) d_transform_length)); // if multiple super audio frames are processed, move this outside this function to avoid multiple allocation
+		unsigned char *tmp_aac_buffer = (unsigned char *)alloca((const unsigned long) d_n_max_bytes_out);
+        #else
 		float tmp_pcm_buffer[(const unsigned long) d_transform_length]; // if multiple super audio frames are processed, move this outside this function to avoid multiple allocation
 		unsigned char tmp_aac_buffer[(const unsigned long) d_n_max_bytes_out];
+        #endif
 
 		for (int j = 0; j < d_n_aac_frames; j++)
 		{
@@ -217,9 +226,15 @@ namespace gr {
 	audio_encoder_svb_impl::make_drm_compliant(unsigned char* aac_buffer)
 	{
 		/* init buffers for CRC, payload and frame lengths */
+        #ifdef _MSC_VER
+		unsigned char *crc_bits = (unsigned char *)alloca((const int) d_n_aac_frames);
+		int *frame_length = (int *)alloca(sizeof(int)*((const int) d_n_aac_frames));
+		unsigned char **frame_pos = (unsigned char **)alloca(sizeof(unsigned char *)*((const int) d_n_aac_frames));
+        #else
 		unsigned char crc_bits[(const int) d_n_aac_frames];
 		int frame_length[(const int) d_n_aac_frames];
 		unsigned char* frame_pos[(const int) d_n_aac_frames];
+        #endif
 		frame_pos[0] = aac_buffer;
 
 		/* create header ( accumulated frame lengths | padding | CRC | audio ) */
@@ -321,7 +336,11 @@ namespace gr {
 		//std::cout << "len_msg_bit: " << len_msg_bit << std::endl;
 		d_n_text_frames = len_msg_bit/(4*8);
 		//std::cout << "d_n_text_frames: " << d_n_text_frames << ", n_segments: " << n_segments << std::endl;
-		unsigned char msg[len_msg_bit];
+		#ifdef _MSC_VER
+        unsigned char *msg = (unsigned char *)alloca(len_msg_bit);
+        #else
+        unsigned char msg[len_msg_bit];
+        #endif
 		memset(msg, 9, len_msg_bit); // set to 9 for debugging purposes
 
 		//std::cout << "msg address: " << (long) &msg[0] << std::endl;
diff --git a/gr-drm/lib/cell_mapping_vcvc_impl.cc b/gr-drm/lib/cell_mapping_vcvc_impl.cc
index 477b819..7bc0f93 100644
--- a/gr-drm/lib/cell_mapping_vcvc_impl.cc
+++ b/gr-drm/lib/cell_mapping_vcvc_impl.cc
@@ -18,6 +18,7 @@
  * Boston, MA 02110-1301, USA.
  */
 
+#define _USE_MATH_DEFINES
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -150,9 +151,17 @@ namespace gr {
 		int freq_pil[3][2];
 		const int time_rows = d_time_rows; // this way we can instance an array with this variable
 		int afs_pil[NUM_AFS_PILOTS][3]; // only used for RM E
+        #ifdef _MSC_VER
+		int **time_pil = (int **)alloca(sizeof(int *)*time_rows);
+        for (size_t i = 0; i < time_rows; i++) time_pil[i] = (int *)alloca(sizeof(int)*2);
+		const int fac_rows = d_fac_rows;
+        int **fac_pos = (int **)alloca(sizeof(int *)*fac_rows);
+        for (size_t i = 0; i < fac_rows; i++) fac_pos[i] = (int *)alloca(sizeof(int)*2);
+        #else
 		int time_pil[time_rows][2];
 		const int fac_rows = d_fac_rows;
 		int fac_pos[fac_rows][2];
+        #endif
 		int unused_carriers_A[3] = {-1, 0, 1};
 
 		switch(d_RM)
diff --git a/gr-drm/lib/drm_tables_mapping.cc b/gr-drm/lib/drm_tables_mapping.cc
index 4960767..dc1788f 100644
--- a/gr-drm/lib/drm_tables_mapping.cc
+++ b/gr-drm/lib/drm_tables_mapping.cc
@@ -21,6 +21,7 @@
  * Boston, MA 02110-1301, USA.
  */
 
+#define _USE_MATH_DEFINES
 #include "drm_tables.h"
 
 /* frequency reference cells [carrier index][phase_index(0,k)]
diff --git a/gr-drm/lib/drm_util.cc b/gr-drm/lib/drm_util.cc
index cccbde7..d4b2f46 100644
--- a/gr-drm/lib/drm_util.cc
+++ b/gr-drm/lib/drm_util.cc
@@ -80,10 +80,17 @@ void
 enqueue_crc(unsigned char* ptr, transm_params* tp, int len, const unsigned short ord) //  see DRM standard, annex D
 {
 	unsigned short rob_mode = tp->cfg().RM();
+    #ifdef _MSC_VER
+	unsigned char *shift_reg = (unsigned char *)alloca(ord); // shift register of length ord
+	unsigned char *shift_reg_prev = (unsigned char *)alloca(ord); // state of register before last shift
+	unsigned char next_lsb; // the bit that results out of XORing the MSb with the input
+	unsigned char *crc_word = (unsigned char *)alloca(ord); // CRC word
+    #else
 	unsigned char shift_reg[ord]; // shift register of length ord
 	unsigned char shift_reg_prev[ord]; // state of register before last shift
 	unsigned char next_lsb; // the bit that results out of XORing the MSb with the input
 	unsigned char crc_word[ord]; // CRC word
+    #endif
 	memset(shift_reg, 1, ord); // set all stages to one (see DRM standard, annex D)
 	memset(shift_reg_prev, 0, ord); // just for debugging purposes
 	switch(ord)
diff --git a/gr-drm/lib/generate_sdc_vb_impl.cc b/gr-drm/lib/generate_sdc_vb_impl.cc
index 6076992..068f700 100644
--- a/gr-drm/lib/generate_sdc_vb_impl.cc
+++ b/gr-drm/lib/generate_sdc_vb_impl.cc
@@ -188,7 +188,11 @@ namespace gr {
 				gr_vector_void_star &output_items)
 	{
 		const unsigned int sdc_length = d_tp->sdc().L();
+        #ifdef _MSC_VER
+        unsigned char *data = (unsigned char *)alloca(sdc_length);
+        #else
 		unsigned char data[sdc_length];
+        #endif
 		memset(data, 0, sdc_length);
 
 		init_data(data);
diff --git a/gr-drm/lib/m3ufile_source_f_impl.cc b/gr-drm/lib/m3ufile_source_f_impl.cc
index 737b0d3..4214c88 100644
--- a/gr-drm/lib/m3ufile_source_f_impl.cc
+++ b/gr-drm/lib/m3ufile_source_f_impl.cc
@@ -118,7 +118,11 @@ namespace gr {
     {
         char ext_header[] = "#EXTM3U";
         const int len_ext_header = strlen(ext_header);
+        #ifdef _MSC_VER
+        char *linebuf = (char *)alloca(len_ext_header);
+        #else
         char linebuf[len_ext_header];
+        #endif
         d_m3u_file.getline(linebuf, len_ext_header+1); // +1 to get the newline character
         if(strcmp(linebuf, ext_header) == 0) // return 0 if equal
         {
diff --git a/gr-drm/lib/partitioning_vbvb_impl.cc b/gr-drm/lib/partitioning_vbvb_impl.cc
index b801252..bf0638d 100644
--- a/gr-drm/lib/partitioning_vbvb_impl.cc
+++ b/gr-drm/lib/partitioning_vbvb_impl.cc
@@ -60,7 +60,11 @@ namespace gr {
 			  gr_vector_void_star &output_items)
     {
 		unsigned char *in = (unsigned char *) input_items[0];
+        #ifdef _MSC_VER
+		unsigned char **out = (unsigned char **)alloca(sizeof(unsigned char *)*(d_n_out));
+        #else
 		unsigned char *out[d_n_out];
+        #endif
 		for(int i = 0; i < d_n_out; i++)
 		{
 			out[i] = (unsigned char*) output_items[i];
diff --git a/gr-drm/lib/qam_map_vbvc_impl.cc b/gr-drm/lib/qam_map_vbvc_impl.cc
index 9abc2d1..6f949af 100644
--- a/gr-drm/lib/qam_map_vbvc_impl.cc
+++ b/gr-drm/lib/qam_map_vbvc_impl.cc
@@ -73,7 +73,11 @@ namespace gr {
 			  gr_vector_const_void_star &input_items,
 			  gr_vector_void_star &output_items)
 	{
+        #ifdef _MSC_VER
+		unsigned char **in = (unsigned char **)alloca(sizeof(unsigned char *)*(d_n_inputs));
+        #else
 		unsigned char *in[d_n_inputs];
+        #endif
 		gr_complex *out = (gr_complex *) output_items[0];
 
 		// define input pointers
diff --git a/gr-drm/lib/scrambler_vbvb_impl.cc b/gr-drm/lib/scrambler_vbvb_impl.cc
index 3dc20a3..a3bd41c 100644
--- a/gr-drm/lib/scrambler_vbvb_impl.cc
+++ b/gr-drm/lib/scrambler_vbvb_impl.cc
@@ -66,7 +66,11 @@ namespace gr {
 				for(int j = 0; j < noutput_items; j++)
 				{
 					// Generate PRBS of length block_len (G(x) = x^9 + x^5 + 1)
+                    #ifdef _MSC_VER
+					unsigned char *prbs = (unsigned char *)alloca(n_reset); // Pseudo random bit sequence array
+                    #else
 					unsigned char prbs[n_reset]; // Pseudo random bit sequence array
+                    #endif
 					unsigned char lfsr[9] = {1, 1, 1, 1, 1, 1, 1, 1, 1}; // inital state: all ones
 					unsigned char lfsr_prev[9]; // holds previous shift register state while shifting
 					unsigned char next_bit;
